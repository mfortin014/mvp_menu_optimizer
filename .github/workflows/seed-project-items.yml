name: Seed Project Items
env:
  LIB_PATH: .github/project-seeds/library.json

on:
  push:
    paths:
      - ".github/project-seeds/pending/**.md"
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  repository-projects: write

concurrency:
  group: seed-${{ github.ref }}
  cancel-in-progress: true

jobs:
  seed:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (full history so diffs work)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: List pending seed files
        id: list
        shell: bash
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
          SEED_GLOB=".github/project-seeds/pending/**.md"

          if [ -z "${BEFORE}" ] || [ "${BEFORE}" = "0000000000000000000000000000000000000000" ]; then
            git ls-files "${SEED_GLOB}" > seeds.txt || true
          else
            ( git diff --name-only "${BEFORE}" "${AFTER}" \
              | grep -E "^\.github/project-seeds/pending/.*\.md$" || true ) > seeds.txt
          fi

          # Keep only files that still exist in the checked-out workspace
          awk '{print}' seeds.txt | while read -r f; do
            [ -f "$f" ] && echo "$f"
          done > seeds_existing.txt

          FILES="$(paste -sd, seeds_existing.txt || true)"
          echo "files=${FILES}" >> "$GITHUB_OUTPUT"

          echo "Seeds in diff:"
          cat seeds.txt || true
          echo "Seeds that still exist:"
          cat seeds_existing.txt || true

      - name: Create issues (create-only) and add to Project
        id: create
        if: steps.list.outputs.files != ''
        uses: actions/github-script@v7

        # IMPORTANT: use PAT so GraphQL can write to Projects v2
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            // 'core', 'github', 'context' are provided by actions/github-script
            const fs = require('fs');
            const path = require('path');

            // ------------------ env ------------------
            const filesRaw = (process.env.FILES || '');
            const files = filesRaw.split(',').map(s => s.trim()).filter(f => f && fs.existsSync(f));
            if (!files.length) { core.info('No existing seed files to process.'); core.setOutput('created','[]'); return; }

            // Prefer PROJECT_ID if you have it (GraphQL node id like "PVT_xxx")
            const PROJECT_ID_OVERRIDE = process.env.PROJECT_ID || '';
            // Human URLs for routing (Variables)
            const DEFAULT_PROJECT_URL  = process.env.DEFAULT_PROJECT_URL  || null;
            const PROJECT_URL_TEST     = process.env.DEFAULT_PROJECT_URL_TEST || null;
            const DEFAULT_ASSIGNEE     = process.env.DEFAULT_ASSIGNEE || '';
            const FALLBACK_ASSIGNEE    = process.env.FALLBACK_ASSIGNEE || '';

            // ---------- helpers ----------
            function parseHeader(body) {
              const m = body.match(/<!--([\s\S]*?)-->/);
              if (!m) return { meta:{}, rest: body.trim() };
              const hdr = m[1];
              const meta = {};
              hdr.split('\n').forEach(line => {
                const L = line.trim();
                if (!L || L.startsWith('#')) return;
                const idx = L.indexOf(':'); if (idx < 0) return;
                const k = L.slice(0, idx).trim();
                let v = L.slice(idx+1).trim();
                // Try strict JSON first (so arrays/quoted strings work)
                try { meta[k] = JSON.parse(v); }
                catch { meta[k] = v.replace(/^"+|"+$/g,''); }
              });
              const rest = body.replace(m[0], '').trim();
              return { meta, rest };
            }

            // GraphQL search (no deprecation) to find an existing issue by seed uid
            async function findIssueByUid(uid) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} in:body "seed-uid:${uid}" is:issue`;
              const data = await github.graphql(
                `query($q:String!){
                  search(query:$q, type:ISSUE, first:1){
                    nodes { ... on Issue { number } }
                  }
                }`,
                { q }
              );
              const node = data?.search?.nodes?.[0];
              if (!node?.number) return null;
              return { number: node.number };
            }

            // Accepts: https://github.com/users/<login>/projects/<n>  OR  https://github.com/orgs/<org>/projects/<n>
            async function resolveProjectIdFromUrl(projectUrl) {
              try {
                if (!projectUrl) return null;

                const orgMatch  = projectUrl.match(/orgs\/([^/]+)\/projects\/(\d+)/);
                const userMatch = projectUrl.match(/users\/([^/]+)\/projects\/(\d+)/);

                if (orgMatch) {
                  const [_, org, n] = orgMatch; const num = parseInt(n,10);
                  const data = await github.graphql(
                    `query($org:String!,$num:Int!){
                      organization(login:$org){ projectV2(number:$num){ id title } }
                    }`, { org, num }
                  );
                  return data?.organization?.projectV2?.id || null;
                }

                if (userMatch) {
                  const [_, user, n] = userMatch; const num = parseInt(n,10);
                  const data = await github.graphql(
                    `query($user:String!,$num:Int!){
                      user(login:$user){ projectV2(number:$num){ id title } }
                    }`, { user, num }
                  );
                  return data?.user?.projectV2?.id || null;
                }

                core.warning(`Unrecognized project URL format: ${projectUrl}`);
                return null;
              } catch (e) {
                core.warning(`Project lookup failed for ${projectUrl}: ${e.message}`);
                return null; // non-fatal
              }
            }

            // Cache project ids per URL within this run
            const projectIdCache = new Map();
            async function getProjectIdForUrl(url) {
              if (!url) return null;
              if (projectIdCache.has(url)) return projectIdCache.get(url);
              const id = await resolveProjectIdFromUrl(url);
              projectIdCache.set(url, id);
              return id;
            }

            // Resolve field metadata once per project (name → {id, kind, options?})
            // NOTE: text/number/date all appear as ProjectV2Field; single-select has options
            const fieldCache = new Map(); // projectId -> Map<lowerName, fieldInfo>
            async function getProjectFields(projectId) {
              if (!projectId) return null;
              if (fieldCache.has(projectId)) return fieldCache.get(projectId);
              const data = await github.graphql(
                `query($id:ID!){
                  node(id:$id){
                    ... on ProjectV2 {
                      fields(first: 50){
                        nodes{
                          __typename
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2Field             { id name dataType }  # text / number / date
                          ... on ProjectV2IterationField    { id name configuration { iterations { id title startDate duration } } }
                        }
                      }
                    }
                  }
                }`, { id: projectId }
              );
              const nodes = data?.node?.fields?.nodes || [];
              const map = new Map();
              for (const n of nodes) {
                if (n.__typename === 'ProjectV2SingleSelectField') {
                  map.set(n.name.toLowerCase(), { id: n.id, name: n.name, kind: 'SINGLE_SELECT', options: n.options || [] });
                } else if (n.__typename === 'ProjectV2IterationField') {
                  const iterations = (n.configuration?.iterations || []).map(it => ({
                    id: it.id,
                    title: it.title,
                    startDate: it.startDate,
                    duration: it.duration,
                  }));
                  map.set(n.name.toLowerCase(), {
                    id: n.id,
                    name: n.name,
                    kind: 'ITERATION',
                    iterations,
                  });
                } else if (n.__typename === 'ProjectV2Field') {
                  const dataType = String(n.dataType || 'TEXT').toUpperCase();
                  let kind = 'TEXT';
                  if (dataType === 'NUMBER') kind = 'NUMBER';
                  else if (dataType === 'DATE') kind = 'DATE';
                  map.set(n.name.toLowerCase(), { id: n.id, name: n.name, kind, dataType });
                }
              }
              fieldCache.set(projectId, map);
              return map;
            }

            // Add to Project and return itemId, even if already present
            async function getOrCreateProjectItem(projectId, issueNumber) {
              if (!projectId || !issueNumber) return null;

              // Resolve issue node id
              const node = await github.graphql(
                `query($o:String!, $r:String!, $n:Int!){
                  repository(owner:$o, name:$r){ issue(number:$n){ id number } }
                }`, { o: context.repo.owner, r: context.repo.repo, n: issueNumber }
              );
              const contentId = node?.repository?.issue?.id;
              if (!contentId) { core.warning(`Could not resolve content node for #${issueNumber}`); return null; }

              // Try to add; if it already exists, fall back to lookup
              try {
                const added = await github.graphql(
                  `mutation($projectId:ID!, $contentId:ID!){
                    addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                  }`, { projectId, contentId }
                );
                const itemId = added?.addProjectV2ItemById?.item?.id || null;
                if (itemId) return itemId;
              } catch (e) {
                core.info(`addProjectV2ItemById: ${e.message} (will try to locate existing item)`);
              }

              // Locate existing item by scanning recent items for matching content
              const data = await github.graphql(
                `query($projectId:ID!,$owner:String!,$repo:String!,$issue:Int!){
                  repository(owner:$owner, name:$repo){ issue(number:$issue){ id } }
                  node(id:$projectId){
                    ... on ProjectV2 {
                      items(first: 100, orderBy:{field:CREATED_AT, direction:DESC}){
                        nodes {
                          id
                          content { __typename ... on Issue { id number } }
                        }
                      }
                    }
                  }
                }`,
                { projectId, owner: context.repo.owner, repo: context.repo.repo, issue: issueNumber }
              );
              const issueId = data?.repository?.issue?.id;
              const items = data?.node?.items?.nodes || [];
              const hit = items.find(n => n?.content?.__typename === 'Issue' && n.content.id === issueId);
              return hit?.id || null;
            }

            // Update a single field value on a Project item
            async function writeFieldValue(projectId, itemId, fieldInfo, rawValue) {
              if (!projectId || !itemId || !fieldInfo) return;
              const fname = fieldInfo.name;
              const kind  = fieldInfo.kind;

              if (rawValue == null || (typeof rawValue === 'string' && rawValue.trim() === '')) {
                core.info(`Field "${fname}": no value provided → skip`);
                return;
              }

              let value;
              if (kind === 'SINGLE_SELECT') {
                const wanted = String(rawValue).trim().toLowerCase();
                const option = (fieldInfo.options || []).find(o => o.name.toLowerCase() === wanted);
                if (!option) {
                  core.warning(`Field "${fname}": option "${rawValue}" not found; available: ${(fieldInfo.options||[]).map(o=>o.name).join(', ')}`);
                  return;
                }
                value = { singleSelectOptionId: option.id };
              } else if (kind === 'NUMBER') {
                const num = Number(rawValue);
                if (!Number.isFinite(num)) {
                  core.warning(`Field "${fname}": value "${rawValue}" is not a number`);
                  return;
                }
                value = { number: num };
              } else if (kind === 'DATE') {
                let iso = null;
                if (rawValue && typeof rawValue === 'object' && !(rawValue instanceof Date)) {
                  if (rawValue.date) iso = String(rawValue.date).trim();
                  else if (rawValue.startDate) iso = String(rawValue.startDate).trim();
                }
                if (!iso) {
                  if (rawValue instanceof Date) {
                    iso = rawValue.toISOString().slice(0, 10);
                  } else {
                    iso = String(rawValue).trim();
                  }
                }
                if (!/^\d{4}-\d{2}-\d{2}$/.test(iso)) {
                  core.warning(`Field "${fname}": date must be YYYY-MM-DD (received "${rawValue}")`);
                  return;
                }
                value = { date: iso };
              } else if (kind === 'ITERATION') {
                const iterations = fieldInfo.iterations || [];
                let match = null;

                if (rawValue && typeof rawValue === 'object') {
                  const candidateId = rawValue.id || rawValue.iterationId;
                  if (candidateId) {
                    match = iterations.find(it => it.id === candidateId);
                  }
                  if (!match && rawValue.title) {
                    const wanted = String(rawValue.title).trim().toLowerCase();
                    match = iterations.find(it => (it.title || '').toLowerCase() === wanted);
                  }
                  if (!match && rawValue.startDate) {
                    const wanted = String(rawValue.startDate).trim().toLowerCase();
                    match = iterations.find(it => (it.startDate || '').toLowerCase() === wanted);
                  }
                } else {
                  const wanted = String(rawValue).trim();
                  const wantedLower = wanted.toLowerCase();
                  match = iterations.find(it =>
                    it.id === wanted ||
                    (it.title || '').toLowerCase() === wantedLower ||
                    (it.startDate || '').toLowerCase() === wantedLower
                  );
                }

                if (!match) {
                  const options = iterations.map(it => `${it.title || it.startDate || it.id}`.trim()).filter(Boolean);
                  core.warning(`Field "${fname}": iteration "${rawValue}" not found; available: ${options.join(', ') || '(none)'}`);
                  return;
                }
                value = { iterationId: match.id };
              } else {
                // Treat as TEXT; covers the policy fields "Target Release", "Doc Link"
                value = { text: String(rawValue) };
              }

              await github.graphql(
                `mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$value:ProjectV2FieldValue!){
                  updateProjectV2ItemFieldValue(input:{projectId:$projectId,itemId:$itemId,fieldId:$fieldId,value:$value}){ projectV2Item { id } }
                }`,
                { projectId, itemId, fieldId: fieldInfo.id, value }
              );
              core.info(`Set "${fname}" = ${JSON.stringify(rawValue)}`);
            }

            // ---------- /helpers ----------
            const STATUS_ALLOWED = ['Draft', 'Ready', 'In Progress', 'In Review', 'Done'];
            const STATUS_REMAPPED = new Map([
              ['accepted', 'Ready'],
              ['todo', 'Ready'],
              ['doing', 'In Progress'],
              ['in-progress', 'In Progress'],
              ['in progress', 'In Progress'],
              ['in-review', 'In Review'],
              ['in review', 'In Review'],
            ]);
            const STATUS_DEPRECATED = new Set(['blocked', 'parked', 'superseded']);
            const STORY_POINT_VALUES = new Set([1, 2, 3, 5, 8, 13]);
            const PRIORITY_ALLOWED = new Set(['P0', 'P1', 'P2', 'P3']);
            const SERIES_DEFAULT = 'Throughput';
            const WORK_TYPE_MAP = new Map([
              ['epic', 'Epic'],
              ['child', 'Child'],
              ['standalone', 'Standalone'],
            ]);
            const DATE_RE = /^\d{4}-\d{2}-\d{2}$/;

            function isBlank(value) {
              return value == null || (typeof value === 'string' && value.trim() === '');
            }

            function normalizeStatusValue(raw) {
              if (isBlank(raw)) {
                return { value: null, error: 'Status is required.' };
              }

              const trimmed = String(raw).trim();
              const lower = trimmed.toLowerCase();

              if (STATUS_DEPRECATED.has(lower)) {
                return {
                  value: null,
                  error: `Status "${trimmed}" was removed. Use a label instead and choose one of: ${STATUS_ALLOWED.join(', ')}.`,
                };
              }

              if (STATUS_REMAPPED.has(lower)) {
                const mapped = STATUS_REMAPPED.get(lower);
                const warning = trimmed === mapped ? null : `Mapped legacy status "${trimmed}" → "${mapped}".`;
                return { value: mapped, warning };
              }

              const canonical = STATUS_ALLOWED.find(s => s.toLowerCase() === lower);
              if (canonical) {
                return { value: canonical, warning: null };
              }

              return { value: null, error: `Status "${trimmed}" not recognized. Use one of: ${STATUS_ALLOWED.join(', ')}.` };
            }

            function coerceIsoDate(raw, fieldName, errors) {
              if (isBlank(raw)) return null;
              let iso = null;
              if (raw && typeof raw === 'object' && !(raw instanceof Date)) {
                if (raw.date) iso = String(raw.date).trim();
                else if (raw.startDate) iso = String(raw.startDate).trim();
              }
              if (!iso) {
                if (raw instanceof Date) {
                  iso = raw.toISOString().slice(0, 10);
                } else {
                  iso = String(raw).trim();
                }
              }
              if (!DATE_RE.test(iso)) {
                errors.push(`${fieldName} must be formatted as YYYY-MM-DD.`);
                return null;
              }
              return iso;
            }

            function normalizeSeedMeta(meta) {
              const normalized = { ...meta };
              const errors = [];
              const warnings = [];

              // Normalized key aliases
              if (normalized.sequence != null && normalized.step == null) normalized.step = normalized.sequence;
              if (normalized.iteration != null && normalized.sprint == null) normalized.sprint = normalized.iteration;
              if (normalized.storypoints != null && normalized.story_points == null) normalized.story_points = normalized.storypoints;

              delete normalized.sequence;
              delete normalized.iteration;
              delete normalized.storypoints;

              normalized.uid = normalized.uid || normalized.id || null;

              const typeRaw = isBlank(normalized.type) ? '' : String(normalized.type).trim();
              if (!typeRaw) errors.push('Missing required "type".');
              normalized.type = typeRaw || normalized.type;
              const childrenSeed = normalized.children_uids;
              let childrenList = [];
              if (Array.isArray(childrenSeed)) {
                childrenList = childrenSeed.filter(Boolean).map(String);
              } else if (!isBlank(childrenSeed)) {
                childrenList = String(childrenSeed)
                  .split(',')
                  .map(s => s.trim())
                  .filter(Boolean);
              }
              normalized.children_uids = childrenList;

              if (!isBlank(normalized.parent_uid)) {
                normalized.parent_uid = String(normalized.parent_uid).trim();
              } else {
                delete normalized.parent_uid;
              }
              const hasParent = Boolean(normalized.parent_uid);
              const hasChildren = childrenList.length > 0;

              let workTypeRaw = isBlank(normalized.work_type) ? '' : String(normalized.work_type).trim();
              if (!workTypeRaw) {
                if (hasParent) workTypeRaw = 'Child';
                else if (hasChildren) workTypeRaw = 'Epic';
                else workTypeRaw = 'Standalone';
              }
              const workTypeCanonical = workTypeRaw.toLowerCase();
              const workTypeValue = WORK_TYPE_MAP.get(workTypeCanonical);
              if (!workTypeValue) {
                errors.push('Work Type must be one of Epic, Child, or Standalone.');
              }
              if (workTypeValue === 'Child' && !hasParent) {
                errors.push('Work Type "Child" requires a parent_uid.');
              }
              if (workTypeValue !== 'Child' && hasParent) {
                errors.push(`Work Type "${workTypeValue || workTypeRaw}" cannot include parent_uid.`);
              }
              if (workTypeValue === 'Epic' && !hasChildren) {
                warnings.push('Epic work items should list children_uids; add them so automation can wire hierarchy.');
              }
              if (workTypeValue === 'Standalone' && hasChildren) {
                errors.push('Standalone work should not include children_uids.');
              }
              normalized.work_type = workTypeValue || workTypeRaw;

              const isEpic = workTypeValue === 'Epic';
              const isChild = workTypeValue === 'Child';

              const statusResult = normalizeStatusValue(normalized.status);
              if (statusResult.error) errors.push(statusResult.error);
              if (statusResult.value) normalized.status = statusResult.value;
              if (statusResult.warning) warnings.push(statusResult.warning);

              // Base required fields
              for (const key of ['priority', 'area']) {
                if (isBlank(normalized[key])) {
                  errors.push(`Missing required "${key}".`);
                } else {
                  normalized[key] = String(normalized[key]).trim();
                }
              }

              if (!isBlank(normalized.priority)) {
                normalized.priority = normalized.priority.toUpperCase();
                if (!PRIORITY_ALLOWED.has(normalized.priority)) {
                  errors.push(`Priority "${normalized.priority}" must be one of ${Array.from(PRIORITY_ALLOWED).join(', ')}.`);
                }
              }

              if (!isBlank(normalized.area)) {
                normalized.area = String(normalized.area).trim();
              }

              // Step / sequence handling
              if (isChild) {
                if (isBlank(normalized.step)) {
                  errors.push('Child issues require "step" to sequence work within the epic.');
                } else {
                  const stepNum = Number(normalized.step);
                  if (!Number.isFinite(stepNum) || !Number.isInteger(stepNum) || stepNum < 1) {
                    errors.push(`Step "${normalized.step}" must be a positive integer.`);
                  } else {
                    normalized.step = stepNum;
                  }
                }
              } else {
                if (!isBlank(normalized.step)) {
                  warnings.push('Step is only applied to child issues; ignoring value.');
                }
                delete normalized.step;
              }

              // Story points handling
              if (isChild) {
                if (isBlank(normalized.story_points)) {
                  errors.push('Child issues require "story_points" for velocity tracking.');
                } else {
                  const sp = Number(normalized.story_points);
                  if (!Number.isFinite(sp) || !Number.isInteger(sp)) {
                    errors.push(`Story Points "${normalized.story_points}" must be a whole number.`);
                  } else if (!STORY_POINT_VALUES.has(sp)) {
                    errors.push(`Story Points "${sp}" must be one of ${Array.from(STORY_POINT_VALUES).join(', ')}.`);
                  } else {
                    normalized.story_points = sp;
                  }
                }
              } else if (isEpic) {
                if (!isBlank(normalized.story_points)) {
                  warnings.push('Epics do not take Story Points; ignoring value.');
                }
                delete normalized.story_points;
              } else if (!isBlank(normalized.story_points)) {
                const sp = Number(normalized.story_points);
                if (!Number.isFinite(sp) || !Number.isInteger(sp)) {
                  errors.push(`Story Points "${normalized.story_points}" must be a whole number.`);
                } else if (!STORY_POINT_VALUES.has(sp)) {
                  errors.push(`Story Points "${sp}" must be one of ${Array.from(STORY_POINT_VALUES).join(', ')}.`);
                } else {
                  normalized.story_points = sp;
                }
              }

              // Series handling
              if (isBlank(normalized.series)) {
                normalized.series = SERIES_DEFAULT;
              } else {
                normalized.series = String(normalized.series).trim();
              }

              // Target Release / Date / Start Date rules
              if (isChild) {
                if (!isBlank(normalized.target)) {
                  warnings.push('Target Release is only tracked on epics or orphan issues; ignoring value.');
                }
                if (!isBlank(normalized.target_date)) {
                  warnings.push('Target Date is only tracked on epics or orphan issues; ignoring value.');
                }
                if (!isBlank(normalized.start_date)) {
                  warnings.push('Start Date is only tracked on epics or orphan issues; ignoring value.');
                }
                delete normalized.target;
                delete normalized.target_date;
                delete normalized.start_date;
              } else {
                if (!isBlank(normalized.target)) {
                  normalized.target = String(normalized.target).trim();
                }
                const targetDate = coerceIsoDate(normalized.target_date, 'Target Date', errors);
                if (targetDate) normalized.target_date = targetDate;
                else delete normalized.target_date;

                const startDate = coerceIsoDate(normalized.start_date, 'Start Date', errors);
                if (startDate) normalized.start_date = startDate;
                else delete normalized.start_date;
              }

              // Sprint (iteration) cleanup
              if (isBlank(normalized.sprint)) {
                delete normalized.sprint;
              } else if (typeof normalized.sprint === 'string') {
                normalized.sprint = normalized.sprint.trim();
              }

              return { meta: normalized, errors, warnings, isChild, isEpic };
            }

            const created = []; // [{ number, uid, meta, createdNew: true }]
            let hadValidationFailure = false;

            for (const f of files) {
              const raw = fs.readFileSync(f, 'utf8');
              const parsed = parseHeader(raw);
              const metaRaw = parsed.meta || {};
              const rest = parsed.rest || '';
              const meta = {};
              for (const [key, value] of Object.entries(metaRaw)) {
                meta[key.toLowerCase()] = value;
              }

              const uid = meta.uid || null;
              if (!uid) {
                core.warning(`Seed ${f} missing 'uid'; skipping.`);
                continue;
              }

              const { meta: normalizedMeta, errors, warnings } = normalizeSeedMeta(meta);
              if (errors.length) {
                for (const msg of errors) {
                  core.error(`Seed ${uid}: ${msg}`);
                }
                hadValidationFailure = true;
                continue;
              }
              for (const msg of warnings) {
                core.warning(`Seed ${uid}: ${msg}`);
              }

              const title  = normalizedMeta.title || path.basename(f);
              const labels = Array.isArray(normalizedMeta.labels) ? normalizedMeta.labels : (normalizedMeta.labels ? [normalizedMeta.labels] : []);
              const assigneeSeed = normalizedMeta.assignees;
              const metaForFields = normalizedMeta;

              // Create-only semantics by default
              const mode      = String(normalizedMeta.mode ?? 'create_only');
              const frozen    = String(normalizedMeta.frozen ?? 'true') === 'true';
              const lifecycle = String(normalizedMeta.lifecycle ?? 'seed_only');
              const createOnly = (mode === 'create_only') || frozen || (lifecycle === 'seed_only');

              const existing = await findIssueByUid(uid);
              if (existing && createOnly) {
                core.info(`Seed ${uid}: issue #${existing.number} exists → create-only SKIP`);
                continue;
              }

              // Assignees: seed > default var > fallback
              let assignees = [];
              if (Array.isArray(assigneeSeed)) assignees = assigneeSeed;
              else if (assigneeSeed)           assignees = [assigneeSeed];
              else if (DEFAULT_ASSIGNEE)         assignees = [DEFAULT_ASSIGNEE];
              else if (FALLBACK_ASSIGNEE)        assignees = [FALLBACK_ASSIGNEE];

              // ------------------ per-seed routing ------------------
              // Priority: (1) meta.project_url → (2) meta.project == "test" → (3) DEFAULT_PROJECT_URL (main)
              const routeSwitch = (normalizedMeta.project || '').toString().trim().toLowerCase();
              const chosenProjectUrl =
                (normalizedMeta.project_url && String(normalizedMeta.project_url)) ||
                (routeSwitch === 'test' ? (PROJECT_URL_TEST || DEFAULT_PROJECT_URL) : DEFAULT_PROJECT_URL) ||
                null;

              // PROJECT_ID override is only safe when a single project is used; ignore it if we have a per-seed URL
              let chosenProjectId = null;
              if (!chosenProjectUrl && PROJECT_ID_OVERRIDE) {
                chosenProjectId = PROJECT_ID_OVERRIDE;
              } else if (chosenProjectUrl) {
                chosenProjectId = await getProjectIdForUrl(chosenProjectUrl);
              }

              // Dry-run diagnostics, before any mutations
              core.notice([
                `Seed: ${uid}`,
                `Routing source: ${normalizedMeta.project_url ? 'seed.project_url' : (routeSwitch === 'test' ? 'vars.PROJECT_URL_TEST' : 'vars.PROJECT_URL (default)')}`,
                `Chosen Project URL: ${chosenProjectUrl || '(N/A; using PROJECT_ID override)'}`,
                `Resolved Project ID: ${chosenProjectId || '(unresolved)'}`
              ].join(' | '));

              const body = `${rest}\n\n<!-- seed-uid:${uid} -->`.trim();

              // CREATE (always continue on failure of project-add)
              const issue = (await github.rest.issues.create({
                owner: context.repo.owner,
                repo:  context.repo.repo,
                title, body, labels, assignees
              })).data;

              // Add to project and get itemId
              const itemId = await getOrCreateProjectItem(chosenProjectId, issue.number);
              if (itemId) core.info(`Project itemId for #${issue.number}: ${itemId}`);

              // ---------- Field writes ----------
              if (chosenProjectId && itemId) {
                const fields = await getProjectFields(chosenProjectId);
                if (!fields) {
                  core.warning('Project fields not resolved; skip field writes.');
                } else {
                  // Map seed keys → Project fields (names must match Project policy)
                  const map = {
                    type:     'Type',            // SINGLE_SELECT
                    status:   'Status',          // SINGLE_SELECT
                    priority: 'Priority',        // SINGLE_SELECT
                    target:   'Target Release',  // SINGLE_SELECT / TEXT
                    target_date: 'Target Date',  // DATE
                    area:     'Area',            // SINGLE_SELECT
                    doc:      'Doc Link',        // TEXT
                    series:   'Series',          // SINGLE_SELECT
                    work_type:'Work Type',       // SINGLE_SELECT
                    story_points: 'Story Points',// NUMBER
                    step:     'Step',            // NUMBER
                    sprint:   'Sprint',          // ITERATION
                    start_date: 'Start Date',    // DATE
                  };

                  for (const [seedKey, fieldName] of Object.entries(map)) {
                    const fieldInfo = fields.get(fieldName.toLowerCase());
                    if (!fieldInfo) {
                      core.warning(`Project is missing field "${fieldName}" → skip`);
                      continue;
                    }
                    await writeFieldValue(chosenProjectId, itemId, fieldInfo, metaForFields[seedKey]);
                  }
                }
              } else {
                core.info('No ProjectId or itemId → skip field writes.');
              }
              // ---------- /Field writes ----------

              created.push({ number: issue.number, uid, meta: metaForFields, createdNew: !existing });
              core.info(`Created issue #${issue.number} for seed ${uid}`);
            }

            if (hadValidationFailure) {
              core.warning('One or more seeds were skipped due to validation errors; review the logs above.');
            }

            core.setOutput('created', JSON.stringify(created));
        env:
          FILES: ${{ steps.list.outputs.files }}
          PROJECT_ID: ${{ vars.PROJECT_ID }}
          DEFAULT_PROJECT_URL: ${{ vars.PROJECT_URL }}
          DEFAULT_PROJECT_URL_TEST: ${{ vars.PROJECT_URL_TEST }}
          FALLBACK_ASSIGNEE: ${{ github.actor }}

      - name: Wire hierarchy (epic checklists + late child linking)
        if: steps.create.outputs.created != ''
        uses: actions/github-script@v7
        env:
          CREATED: ${{ steps.create.outputs.created }}
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            // 'core', 'github', 'context' provided

            // GraphQL search avoids deprecation; returns issue number by seed-uid
            async function findIssueByUid(uid) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} in:body "seed-uid:${uid}" is:issue`;
              const data = await github.graphql(
                `query($q:String!){
                  search(query:$q, type:ISSUE, first:1){
                    nodes { ... on Issue { number } }
                  }
                }`,
                { q }
              );
              const node = data?.search?.nodes?.[0];
              if (!node?.number) return null;
              return { number: node.number };
            }

            const created = JSON.parse(process.env.CREATED || '[]');
            const byUid = Object.fromEntries(created.map(i => [i.uid, i]));

            // 1) Newly created epics → write Children checklist once
            for (const item of created) {
              const meta = item.meta || {};

              // Accept JSON array (preferred) or CSV string (legacy)
              const rawChildren = meta.children_uids ?? [];
              const children = Array.isArray(rawChildren)
                ? rawChildren
                : String(rawChildren || '').split(',').map(s => s.trim()).filter(Boolean);

              if (!children.length || !item.createdNew) continue;

              const childNums = children.map(u => byUid[u]?.number).filter(Boolean);
              if (!childNums.length) continue;

              const issue = await github.rest.issues.get({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: item.number
              });

              const header = "## Children\n";
              const list = childNums.map(n => `- [ ] #${n}`).join('\n');
              const body = `${issue.data.body}\n\n${header}${list}\n`;

              await github.rest.issues.update({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: item.number, body
              });
              core.info(`Epic #${item.number}: wrote initial Children list`);
            }

            // 2) Newly created children → append to existing epic (idempotent)
            for (const item of created) {
              const meta = item.meta || {};
              const parentUid = meta.parent_uid;
              if (!parentUid) continue;

              const parent = await findIssueByUid(parentUid);
              if (!parent) { core.warning(`Child #${item.number}: parent_uid=${parentUid} not found`); continue; }

              const parentIssue = await github.rest.issues.get({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: parent.number
              });

              const line = `- [ ] #${item.number}`;
              const header = "## Children";
              let body = parentIssue.data.body || "";

              if (!body.includes(header)) {
                body = `${body}\n\n${header}\n${line}\n`;
              } else if (!body.includes(line)) {
                body = body.replace(
                  /## Children[^\n]*\n((?:- \[ \] #[0-9]+\n)*)/m,
                  (m, list) => `## Children\n${list || ""}${line}\n`
                );
              } else {
                continue; // already linked
              }

              await github.rest.issues.update({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: parent.number, body
              });
              core.info(`Linked child #${item.number} under epic #${parent.number}`);
            }

      - name: Upsert library.json (maintain)
        if: steps.create.outputs.created != ''
        uses: actions/github-script@v7
        env:
          CREATED: ${{ steps.create.outputs.created }}
          LIB_PATH: ${{ env.LIB_PATH }}
          DEFAULT_PROJECT_URL: ${{ vars.PROJECT_URL }}
          DEFAULT_PROJECT_URL_TEST: ${{ vars.PROJECT_URL_TEST }}
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { readJsonFile, writeJsonAtomic, stableSortRecords, dedupeByUid, validateRecord } = require('./scripts/lib/json_io');
            const { resolveProjectItemId } = require('./scripts/lib/uid_resolver');

            const created = JSON.parse(process.env.CREATED || '[]');
            const LIB_PATH = process.env.LIB_PATH || '.github/project-seeds/library.json';
            const [owner, repo] = (process.env.GITHUB_REPOSITORY || '').split('/');

            // Resolve Project ID for field writes routing (use the same logic as create step)
            // We don’t need per-seed URLs here; just check the default Project for item linkage.
            async function resolveDefaultProjectId() {
              const url = process.env.PROJECT_URL || (process.env.DEFAULT_PROJECT_URL || '');
              if (!url) return null;
              const mu = url.match(/github\.com\/users\/([^/]+)\/projects\/(\d+)/i);
              const mo = url.match(/github\.com\/orgs\/([^/]+)\/projects\/(\d+)/i);
              const mr = url.match(/github\.com\/repos\/([^/]+)\/([^/]+)\/projects\/(\d+)/i);
              if (mu) {
                const [, login, n] = mu; const number = parseInt(n,10);
                const r = await github.graphql(`query($login:String!, $number:Int!){ user(login:$login){ projectV2(number:$number){ id } } }`, { login, number });
                return r?.user?.projectV2?.id || null;
              }
              if (mo) {
                const [, org, n] = mo; const number = parseInt(n,10);
                const r = await github.graphql(`query($org:String!, $number:Int!){ organization(login:$org){ projectV2(number:$number){ id } } }`, { org, number });
                return r?.organization?.projectV2?.id || null;
              }
              if (mr) {
                const [, o, rname, n] = mr; const number = parseInt(n,10);
                const r = await github.graphql(`query($owner:String!, $repo:String!, $number:Int!){ repository(owner:$owner,name:$repo){ projectV2(number:$number){ id } } }`, { owner:o, repo:rname, number });
                return r?.repository?.projectV2?.id || null;
              }
              return null;
            }

            const PROJECT_ID = await resolveDefaultProjectId();

            // Load existing library (if any)
            let lib = readJsonFile(LIB_PATH);
            if (!Array.isArray(lib)) lib = [];

            // Build/merge records for newly created items
            for (const item of created) {
              const uid = item.uid;
              const issue_number = item.number;

              // Resolve issue node id
              const issueQ = `query($o:String!, $r:String!, $n:Int!){ repository(owner:$o,name:$r){ issue(number:$n){ id number } } }`;
              const issueRes = await github.graphql(issueQ, { o: owner, r: repo, n: issue_number });
              const issue_node_id = issueRes?.repository?.issue?.id || null;

              // Optional: resolve project item id in the default/main project (may be null if not on it)
              let project_item_id = null;
              if (PROJECT_ID && issue_node_id) {
                try {
                  project_item_id = await resolveProjectItemId({ octokit: github, projectId: PROJECT_ID, issueNodeId: issue_node_id });
                } catch (e) {
                  core.warning(`library upsert: project item lookup failed for #${issue_number}: ${String(e)}`);
                }
              }

              // parent_uid is a seed UID; it lives in the seed meta that was echoed back in create step
              const parent_uid = (item.meta && item.meta.parent_uid) ? String(item.meta.parent_uid) : null;

              const record = {
                uid, parent_uid, owner, repo,
                issue_number, issue_node_id, project_item_id,
                created_at: new Date().toISOString()
              };

              const i = lib.findIndex(r => r.uid === uid);
              if (i === -1) lib.push(record);
              else {
                const keepCreatedAt = lib[i].created_at || record.created_at;
                lib[i] = { ...lib[i], ...record, created_at: keepCreatedAt };
              }
            }

            // Clean, validate, write atomically
            const clean = stableSortRecords(dedupeByUid(lib));
            const bad = clean.filter(r => !validateRecord(r)).map(r => r.uid);
            if (bad.length) core.warning(`library.json invalid entries (still writing): ${bad.join(', ')}`);

            const dir = path.dirname(LIB_PATH);
            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
            writeJsonAtomic(LIB_PATH, clean);
            core.notice(`library.json upserted with ${created.length} item(s).`);

      - name: Link native parent/child relationships
        if: steps.create.outputs.created != ''
        uses: actions/github-script@v7
        env:
          LIB_PATH: ${{ env.LIB_PATH }}
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            const { linkFromLibrary } = require('./scripts/lib/link_sub_issue.js');
            const libraryPath = process.env.LIB_PATH || '.github/project-seeds/library.json';
            await linkFromLibrary({
              octokit: github,
              core,
              owner: context.repo.owner,
              repo: context.repo.repo,
              dryRun: false,
              libraryPath,
            });

      - name: Move processed seeds (pending → applied) and open PR if allowed
        if: steps.list.outputs.files != ''
        uses: actions/github-script@v7
        env:
          FILES: ${{ steps.list.outputs.files }}
          # Repo variable to control auto-PR creation. Default false if unset.
          ALLOW_AUTOCONSUME_PR: ${{ vars.ALLOW_AUTOCONSUME_PR || 'false' }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const files = (process.env.FILES || '').split(',').map(s => s.trim()).filter(f => f && fs.existsSync(f));
            if (!files.length) { core.info('No seeds to consume'); return; }

            // Parse guard (explicitly opt-in)
            const allowPR = String(process.env.ALLOW_AUTOCONSUME_PR || 'false').toLowerCase() === 'true';

            function parseHeader(body) {
              const m = body.match(/<!--([\s\S]*?)-->/);
              if (!m) return { meta:{} };
              const hdr = m[1];
              const meta = {};
              hdr.split('\n').forEach(line => {
                const L = line.trim();
                if (!L || L.startsWith('#')) return;
                const idx = L.indexOf(':'); if (idx < 0) return;
                const k = L.slice(0, idx).trim();
                let v = L.slice(idx+1).trim();
                try { meta[k] = JSON.parse(v); }
                catch { meta[k] = v.replace(/^"+|"+$/g,''); }
              });
              return { meta };
            }

            function slugify(s) {
              return String(s).toLowerCase().replace(/[^a-z0-9._-]+/g,'-').replace(/^-+|-+$/g,'');
            }

            // Collect UIDs (fallback to filename stem) for traceable branch names
            const uids = [];
            for (const f of files) {
              const raw = fs.readFileSync(f, 'utf8');
              const { meta } = parseHeader(raw);
              const uid = meta.uid || path.basename(f).replace(/\.md$/,'');
              if (uid) uids.push(uid);
            }

            let branchBase;
            if (uids.length === 1) {
              branchBase = slugify(uids[0]);
            } else if (uids.length <= 3) {
              branchBase = uids.map(slugify).join('+');
            } else {
              branchBase = `${slugify(uids[0])}-and-${uids.length-1}-more`;
            }
            const branch = `automation/consume/${branchBase}-${Date.now()}`;

            // Use the branch the workflow ran on as the PR base (feature branches stay clean)
            const baseBranch =
              (context.eventName === 'pull_request' && context.payload.pull_request?.base?.ref)
              || process.env.GITHUB_REF_NAME
              || 'main';

            // Commit moves to a short-lived branch (never push to base directly)
            execSync('git config user.name "github-actions[bot]"');
            execSync('git config user.email "41898282+github-actions[bot]@users.noreply.github.com"');
            execSync(`git checkout -b "${branch}"`);

            for (const f of files) {
              const target = f.replace('/pending/', '/applied/');
              execSync(`mkdir -p "$(dirname "${target}")"`);
              execSync(`git mv "${f}" "${target}"`);
            }

            execSync('git add -A .github/project-seeds');
            execSync('git commit -m "chore(automation): consume seeds → applied/ [' + uids.join(', ') + ']"');
            execSync(`git push --quiet --set-upstream origin "${branch}"`);

            core.notice(`Consume branch: ${branch}`);

            // Open PR only when explicitly allowed; otherwise provide the compare link as a notice
            const compareUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(branch)}?expand=1&template=consume.md`;

            if (!allowPR) {
              core.notice('Auto-PR disabled by ALLOW_AUTOCONSUME_PR=false. Open manually: ' + compareUrl);
              return;
            }

            try {
              const pr = await github.rest.pulls.create({
                owner: context.repo.owner, repo: context.repo.repo,
                head: branch, base: baseBranch,
                title: `chore(automation): consume seeds → applied/ [${uids.join(', ')}]`,
                body: 'Move processed seeds from pending/ to applied/ to enforce create-only snapshots.'
              });
              core.notice(`Opened consume PR #${pr.data.number}`);
              core.notice(`Consume PR: ${pr.data.html_url} (base=${baseBranch})`);
              core.notice(`(Heads up) Ignore any earlier 'Create a pull request...' link from git; it always targets the default branch.`);

            } catch (e) {
              // If policy still blocks PR creation, fall back to manual link
              core.warning('Auto-PR failed; open manually: ' + compareUrl + ` | reason: ${e.message}`);
            }
