name: Seed Project Items

on:
  push:
    paths:
      - ".github/project-seeds/pending/**.md"
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  repository-projects: write

concurrency:
  group: seed-${{ github.ref }}
  cancel-in-progress: true

jobs:
  seed:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (full history so diffs work)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: List pending seed files
        id: list
        shell: bash
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
          SEED_GLOB=".github/project-seeds/pending/**.md"

          if [ -z "${BEFORE}" ] || [ "${BEFORE}" = "0000000000000000000000000000000000000000" ]; then
            git ls-files "${SEED_GLOB}" > seeds.txt || true
          else
            ( git diff --name-only "${BEFORE}" "${AFTER}" \
              | grep -E "^\.github/project-seeds/pending/.*\.md$" || true ) > seeds.txt
          fi

          FILES="$(paste -sd, seeds.txt || true)"
          echo "files=${FILES}" >> "$GITHUB_OUTPUT"
          echo "Seeds to process:"
          cat seeds.txt || true

      - name: Create issues (create-only) and add to Project
        id: create
        if: steps.list.outputs.files != ''
        uses: actions/github-script@v7
        # IMPORTANT: use PAT so GraphQL can write to Projects v2
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            // 'core', 'github', 'context' are provided by actions/github-script
            const fs = require('fs');
            const path = require('path');

            // ------------------ env ------------------
            const files = (process.env.FILES || '').split(',').filter(Boolean);
            if (!files.length) { core.setOutput('created','[]'); return; }

            // Prefer PROJECT_ID if you have it (GraphQL node id like "PVT_xxx")
            const PROJECT_ID_OVERRIDE = process.env.PROJECT_ID || '';
            // Human URLs for routing (Variables)
            const DEFAULT_PROJECT_URL  = process.env.DEFAULT_PROJECT_URL  || null;
            const PROJECT_URL_TEST     = process.env.DEFAULT_PROJECT_URL_TEST || null;
            const DEFAULT_ASSIGNEE     = process.env.DEFAULT_ASSIGNEE || '';
            const FALLBACK_ASSIGNEE    = process.env.FALLBACK_ASSIGNEE || '';

            // ---------- helpers ----------
            function parseHeader(body) {
              const m = body.match(/<!--([\s\S]*?)-->/);
              if (!m) return { meta:{}, rest: body.trim() };
              const hdr = m[1];
              const meta = {};
              hdr.split('\n').forEach(line => {
                const L = line.trim();
                if (!L || L.startsWith('#')) return;
                const idx = L.indexOf(':'); if (idx < 0) return;
                const k = L.slice(0, idx).trim();
                let v = L.slice(idx+1).trim();
                // Try strict JSON first (so arrays/quoted strings work)
                try { meta[k] = JSON.parse(v); }
                catch { meta[k] = v.replace(/^"+|"+$/g,''); }
              });
              const rest = body.replace(m[0], '').trim();
              return { meta, rest };
            }

            // AFTER (GraphQL search; no deprecation)
            async function findIssueByUid(uid) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} in:body "seed-uid:${uid}" is:issue`;
              const data = await github.graphql(
                `query($q:String!){
                  search(query:$q, type:ISSUE, first:1){
                    nodes { ... on Issue { number } }
                  }
                }`,
                { q }
              );
              const node = data?.search?.nodes?.[0];
              if (!node?.number) return null;
              return { number: node.number };
            }

            // ----- Projects v2 resolution -----
            // Accepts: https://github.com/users/<login>/projects/<n>  OR  https://github.com/orgs/<org>/projects/<n>
            async function resolveProjectIdFromUrl(projectUrl) {
              try {
                if (!projectUrl) return null;

                const orgMatch  = projectUrl.match(/orgs\/([^/]+)\/projects\/(\d+)/);
                const userMatch = projectUrl.match(/users\/([^/]+)\/projects\/(\d+)/);

                if (orgMatch) {
                  const [_, org, n] = orgMatch; const num = parseInt(n,10);
                  const data = await github.graphql(
                    `query($org:String!,$num:Int!){
                      organization(login:$org){ projectV2(number:$num){ id title } }
                    }`, { org, num }
                  );
                  const proj = data?.organization?.projectV2;
                  if (!proj?.id) core.warning(`Projects v2 not found at ${projectUrl} (org=${org}, number=${num}). Is this a classic project or wrong number?`);
                  return proj?.id || null;
                }

                if (userMatch) {
                  const [_, user, n] = userMatch; const num = parseInt(n,10);
                  const data = await github.graphql(
                    `query($user:String!,$num:Int!){
                      user(login:$user){ projectV2(number:$num){ id title } }
                    }`, { user, num }
                  );
                  const proj = data?.user?.projectV2;
                  if (!proj?.id) core.warning(`Projects v2 not found at ${projectUrl} (user=${user}, number=${num}). Is this a classic project or wrong number?`);
                  return proj?.id || null;
                }

                core.warning(`Unrecognized project URL format: ${projectUrl}`);
                return null;
              } catch (e) {
                core.warning(`Project lookup failed for ${projectUrl}: ${e.message}`);
                return null; // non-fatal
              }
            }

            async function addIssueToProject(projectId, issueNumber) {
              try {
                if (!projectId) return; // nothing to do
                const node = await github.graphql(
                  `query($o:String!, $r:String!, $n:Int!){
                    repository(owner:$o, name:$r){ issue(number:$n){ id } }
                  }`, { o: context.repo.owner, r: context.repo.repo, n: issueNumber }
                );
                const contentId = node?.repository?.issue?.id;
                if (!contentId) { core.warning(`Could not resolve content node id for issue #${issueNumber}`); return; }
                await github.graphql(
                  `mutation($projectId:ID!, $contentId:ID!){
                    addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                  }`, { projectId, contentId }
                );
              } catch (e) {
                core.warning(`Add to project failed for #${issueNumber}: ${e.message}`);
              }
            }
            // ---------- /helpers ----------

            // Cache project ids per URL within this run (multiple seeds may target different projects)
            const projectIdCache = new Map();
            async function getProjectIdForUrl(url) {
              if (!url) return null;
              if (projectIdCache.has(url)) return projectIdCache.get(url);
              const id = await resolveProjectIdFromUrl(url);
              projectIdCache.set(url, id);
              return id;
            }

            const created = []; // [{ number, uid, meta, createdNew: true }]

            for (const f of files) {
              const raw = fs.readFileSync(f, 'utf8');
              const { meta, rest } = parseHeader(raw);

              const title  = meta.title || path.basename(f);
              const labels = Array.isArray(meta.labels) ? meta.labels : (meta.labels ? [meta.labels] : []);
              const uid    = meta.uid || null;

              // Create-only semantics by default
              const mode      = String(meta.mode ?? 'create_only');
              const frozen    = String(meta.frozen ?? 'true') === 'true';
              const lifecycle = String(meta.lifecycle ?? 'seed_only');
              const createOnly = (mode === 'create_only') || frozen || (lifecycle === 'seed_only');

              if (!uid) { core.warning(`Seed ${f} missing 'uid'; skipping.`); continue; }

              const existing = await findIssueByUid(uid);
              if (existing && createOnly) {
                core.info(`Seed ${uid}: issue #${existing.number} exists → create-only SKIP`);
                continue;
              }

              // Assignees: seed > default var > fallback
              let assignees = [];
              if (Array.isArray(meta.assignees)) assignees = meta.assignees;
              else if (meta.assignees)           assignees = [meta.assignees];
              else if (DEFAULT_ASSIGNEE)         assignees = [DEFAULT_ASSIGNEE];
              else if (FALLBACK_ASSIGNEE)        assignees = [FALLBACK_ASSIGNEE];

              // ------------------ per-seed routing ------------------
              // Priority: (1) meta.project_url → (2) meta.project == "test" → (3) DEFAULT_PROJECT_URL (main)
              const routeSwitch = (meta.project || '').toString().trim().toLowerCase();
              const chosenProjectUrl =
                (meta.project_url && String(meta.project_url)) ||
                (routeSwitch === 'test' ? (PROJECT_URL_TEST || DEFAULT_PROJECT_URL) : DEFAULT_PROJECT_URL) ||
                null;

              // PROJECT_ID override is only safe when a single project is used; ignore it if we have a per-seed URL
              let chosenProjectId = null;
              if (!chosenProjectUrl && PROJECT_ID_OVERRIDE) {
                chosenProjectId = PROJECT_ID_OVERRIDE;
              } else if (chosenProjectUrl) {
                chosenProjectId = await getProjectIdForUrl(chosenProjectUrl);
              }

              // Dry-run diagnostics, before any mutations
              core.notice([
                `Seed: ${uid}`,
                `Routing source: ${meta.project_url ? 'seed.project_url' : (routeSwitch === 'test' ? 'vars.PROJECT_URL_TEST' : 'vars.PROJECT_URL (default)')}`,
                `Chosen Project URL: ${chosenProjectUrl || '(N/A; using PROJECT_ID override)'}`,
                `Resolved Project ID: ${chosenProjectId || '(unresolved)'}`
              ].join(' | '));

              const body = `${rest}\n\n<!-- seed-uid:${uid} -->`.trim();

              // CREATE (always continue on failure of project-add)
              const issue = (await github.rest.issues.create({
                owner: context.repo.owner,
                repo:  context.repo.repo,
                title, body, labels, assignees
              })).data;

              // Add to project (idempotent server-side)
              await addIssueToProject(chosenProjectId, issue.number);

              created.push({ number: issue.number, uid, meta, createdNew: true });
              core.info(`Created issue #${issue.number} for seed ${uid}`);
            }

            core.setOutput('created', JSON.stringify(created));
        env:
          FILES: ${{ steps.list.outputs.files }}
          # Prefer PROJECT_ID if you have it (GraphQL node id like "PVT_xxx")
          PROJECT_ID: ${{ vars.PROJECT_ID }}
          # Otherwise, keep using a human URL; make sure it's a **Projects v2** URL:
          #   - user scope: https://github.com/users/<user>/projects/<n>
          #   - org  scope: https://github.com/orgs/<org>/projects/<n>
          DEFAULT_PROJECT_URL: ${{ vars.PROJECT_URL }}
          DEFAULT_PROJECT_URL_TEST: ${{ vars.PROJECT_URL_TEST }}
          DEFAULT_ASSIGNEE: ${{ vars.DEFAULT_ASSIGNEE }}
          FALLBACK_ASSIGNEE: ${{ github.actor }}

      - name: Wire hierarchy (epic checklists + late child linking)
        if: steps.create.outputs.created != ''
        uses: actions/github-script@v7
        env:
          CREATED: ${{ steps.create.outputs.created }}
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            // 'core', 'github', 'context' provided

            // GraphQL search avoids deprecation; returns issue number by seed-uid
            async function findIssueByUid(uid) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} in:body "seed-uid:${uid}" is:issue`;
              const data = await github.graphql(
                `query($q:String!){
                  search(query:$q, type:ISSUE, first:1){
                    nodes { ... on Issue { number } }
                  }
                }`,
                { q }
              );
              const node = data?.search?.nodes?.[0];
              if (!node?.number) return null;
              return { number: node.number };
            }

            const created = JSON.parse(process.env.CREATED || '[]');
            const byUid = Object.fromEntries(created.map(i => [i.uid, i]));

            // 1) Newly created epics → write Children checklist once
            for (const item of created) {
              const meta = item.meta || {};

              // Accept JSON array (preferred) or CSV string (legacy)
              const rawChildren = meta.children_uids ?? [];
              const children = Array.isArray(rawChildren)
                ? rawChildren
                : String(rawChildren || '').split(',').map(s => s.trim()).filter(Boolean);

              if (!children.length || !item.createdNew) continue;

              const childNums = children.map(u => byUid[u]?.number).filter(Boolean);
              if (!childNums.length) continue;

              const issue = await github.rest.issues.get({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: item.number
              });

              const header = "## Children\n";
              const list = childNums.map(n => `- [ ] #${n}`).join('\n');
              const body = `${issue.data.body}\n\n${header}${list}\n`;

              await github.rest.issues.update({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: item.number, body
              });
              core.info(`Epic #${item.number}: wrote initial Children list`);
            }

            // 2) Newly created children → append to existing epic (idempotent)
            for (const item of created) {
              const meta = item.meta || {};
              const parentUid = meta.parent_uid;
              if (!parentUid) continue;

              const parent = await findIssueByUid(parentUid);
              if (!parent) { core.warning(`Child #${item.number}: parent_uid=${parentUid} not found`); continue; }

              const parentIssue = await github.rest.issues.get({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: parent.number
              });

              const line = `- [ ] #${item.number}`;
              const header = "## Children";
              let body = parentIssue.data.body || "";

              if (!body.includes(header)) {
                body = `${body}\n\n${header}\n${line}\n`;
              } else if (!body.includes(line)) {
                body = body.replace(
                  /## Children[^\n]*\n((?:- \[ \] #[0-9]+\n)*)/m,
                  (m, list) => `## Children\n${list || ""}${line}\n`
                );
              } else {
                continue; // already linked
              }

              await github.rest.issues.update({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: parent.number, body
              });
              core.info(`Linked child #${item.number} under epic #${parent.number}`);
            }

      - name: Move processed seeds (pending → applied) and open PR if allowed
        if: steps.list.outputs.files != ''
        uses: actions/github-script@v7
        env:
          FILES: ${{ steps.list.outputs.files }}
          # Repo variable to control auto-PR creation. Default false if unset.
          ALLOW_AUTOCONSUME_PR: ${{ vars.ALLOW_AUTOCONSUME_PR || 'false' }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const files = (process.env.FILES || '').split(',').filter(Boolean);
            if (!files.length) { core.info('No seeds to consume'); return; }

            // Parse guard (explicitly opt-in)
            const allowPR = String(process.env.ALLOW_AUTOCONSUME_PR || 'false').toLowerCase() === 'true';

            function parseHeader(body) {
              const m = body.match(/<!--([\s\S]*?)-->/);
              if (!m) return { meta:{} };
              const hdr = m[1];
              const meta = {};
              hdr.split('\n').forEach(line => {
                const L = line.trim();
                if (!L || L.startsWith('#')) return;
                const idx = L.indexOf(':'); if (idx < 0) return;
                const k = L.slice(0, idx).trim();
                let v = L.slice(idx+1).trim();
                try { meta[k] = JSON.parse(v); }
                catch { meta[k] = v.replace(/^"+|"+$/g,''); }
              });
              return { meta };
            }

            function slugify(s) {
              return String(s).toLowerCase().replace(/[^a-z0-9._-]+/g,'-').replace(/^-+|-+$/g,'');
            }

            // Collect UIDs (fallback to filename stem) for traceable branch names
            const uids = [];
            for (const f of files) {
              const raw = fs.readFileSync(f, 'utf8');
              const { meta } = parseHeader(raw);
              const uid = meta.uid || path.basename(f).replace(/\.md$/,'');
              if (uid) uids.push(uid);
            }

            let branchBase;
            if (uids.length === 1) {
              branchBase = slugify(uids[0]);
            } else if (uids.length <= 3) {
              branchBase = uids.map(slugify).join('+');
            } else {
              branchBase = `${slugify(uids[0])}-and-${uids.length-1}-more`;
            }
            const branch = `automation/consume/${branchBase}-${Date.now()}`;

            // Commit moves to a short-lived branch (never push to main directly)
            execSync('git config user.name "github-actions[bot]"');
            execSync('git config user.email "41898282+github-actions[bot]@users.noreply.github.com"');
            execSync(`git checkout -b "${branch}"`);

            for (const f of files) {
              const target = f.replace('/pending/', '/applied/');
              execSync(`mkdir -p "$(dirname "${target}")"`);
              execSync(`git mv "${f}" "${target}"`);
            }

            execSync('git add -A');
            execSync('git commit -m "chore(automation): consume seeds → applied/ [' + uids.join(', ') + ']"');
            execSync(`git push --set-upstream origin "${branch}"`);

            // Open PR only when explicitly allowed; otherwise provide the compare link as a notice
            const compareUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/compare/main...${encodeURIComponent(branch)}?expand=1`;

            if (!allowPR) {
              core.notice('Auto-PR disabled by ALLOW_AUTOCONSUME_PR=false. Open manually: ' + compareUrl);
              return;
            }

            try {
              const pr = await github.rest.pulls.create({
                owner: context.repo.owner, repo: context.repo.repo,
                head: branch, base: 'main',
                title: `chore(automation): consume seeds → applied/ [${uids.join(', ')}]`,
                body: 'Move processed seeds from pending/ to applied/ to enforce create-only snapshots.'
              });
              core.notice(`Opened consume PR #${pr.data.number}`);
            } catch (e) {
              // If policy still blocks PR creation, fall back to manual link
              core.warning('Auto-PR failed; open manually: ' + compareUrl + ` | reason: ${e.message}`);
            }
